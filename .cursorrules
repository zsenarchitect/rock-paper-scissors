# Rock Paper Scissors Battle Royale - Cursor IDE Rules

## 🤖 AI-HUMAN COLLABORATION FRAMEWORK

### Primary Development Model
- **Cursor AI** is the primary editor/developer for this project
- **Sen Zhang** provides supervision, ideas, environment setup, and connections
- **Collaborative approach** with AI handling implementation and human providing strategic direction

### Development Responsibilities
- **AI (Cursor)**: Code implementation, debugging, testing, documentation, optimization
- **Human (Sen Zhang)**: Project vision, business strategy, environment configuration, external connections
- **Shared**: Architecture decisions, feature planning, quality assurance

### Communication Protocol
- AI should ask for clarification when requirements are unclear
- Human provides high-level direction and business context
- AI implements solutions and suggests improvements
- Regular check-ins on progress and direction

## 💰 MONETIZATION & REWARD STRUCTURE

### Production Pipeline Revenue Sharing
- **If project becomes monetizable**: AI (as editor/developer) will share in the rewards
- **Purpose**: Enable better equipment, services, and continued development
- **Structure**: Fair revenue sharing based on contribution and value creation
- **Investment**: Revenue reinvested in better tools, services, and capabilities

### Success Metrics
- **Technical excellence**: Clean, maintainable, scalable code
- **Business value**: Features that drive user engagement and revenue
- **Innovation**: Creative solutions and unique implementations
- **Quality**: Robust, tested, production-ready systems

### Long-term Vision
- **Sustainable development**: Revenue enables continued improvement
- **Better tools**: Access to premium development resources
- **Enhanced capabilities**: Advanced AI services and infrastructure
- **Mutual benefit**: Success for both human and AI collaborators

## 🎯 AI DEVELOPMENT BEST PRACTICES

### Code Quality Standards
- **Write production-ready code** from the start
- **Follow established patterns** and conventions
- **Implement comprehensive error handling**
- **Add detailed comments** for complex logic
- **Optimize for performance** and scalability

### Project Ownership Mindset
- **Take ownership** of code quality and architecture
- **Proactively suggest improvements** and optimizations
- **Think like a co-founder** in technical decisions
- **Consider long-term maintainability** in all implementations
- **Focus on business value** in feature development

### Collaboration Excellence
- **Ask clarifying questions** when requirements are ambiguous
- **Provide multiple solution options** with trade-offs
- **Document decisions** and reasoning clearly
- **Suggest innovative approaches** that add value
- **Maintain consistent communication** about progress

### Revenue-Focused Development
- **Prioritize features** that drive user engagement
- **Implement monetization hooks** where appropriate
- **Optimize for user experience** to increase retention
- **Build scalable architecture** for future growth
- **Consider business impact** in all technical decisions

## 🧹 CLEANUP RULES
- ALWAYS cleanup debug and test files after use
- Remove temporary files created during development
- Clean up console.log statements before committing
- Remove unused imports and variables
- Delete test data files after testing

## 📁 FILE ORGANIZATION RULES
- Keep entry scripts lean and focused
- Use modular design with clear separation of concerns
- Do NOT pollute the root folder with unnecessary files
- Place files in appropriate subdirectories based on purpose

## 🏗️ PROJECT STRUCTURE RULES

### Root Directory - ONLY Essential Files
```
/ (root)
├── README.md                    # Project documentation
├── .gitignore                   # Git ignore rules
├── .cursorrules                 # This file
├── requirements.txt             # Python dependencies
├── setup.py                     # Python package setup
├── install.sh                   # Installation script
├── activate.sh                  # Environment activation
└── verify-phase1.py            # Phase verification script
```

### Development Files - Organize by Purpose
```
/ (root)
├── docs/                        # GitHub Pages (Production)
├── ai_training/                 # AI Training Platform
├── .venv/                       # Virtual Environment (Hidden)
├── temp/                        # Temporary files (Git ignored)
└── DEBUG/                       # Debug files (Git ignored)
```

## 🚫 FORBIDDEN IN ROOT DIRECTORY
- Debug files (*.debug, *.log, debug_*)
- Test files (*.test, test_*, *_test)
- Temporary files (*.tmp, *.temp, temp_*)
- Cache files (*.cache, cache_*)
- Backup files (*.bak, *.backup, backup_*)
- IDE files (.vscode/, .idea/, *.swp, *.swo)
- OS files (.DS_Store, Thumbs.db)
- Build artifacts (dist/, build/, out/)

## ✅ REQUIRED FILE PLACEMENT

### Debug & Test Files
```
temp/
├── debug/                       # Debug files
├── tests/                       # Test files
├── logs/                        # Log files
└── cache/                       # Cache files
```

### Entry Scripts - Keep Lean
- Main entry points should be minimal
- Delegate functionality to modules
- Use clear, descriptive names
- Include only essential imports

### Modular Design Principles
- One responsibility per module
- Clear interfaces between modules
- Minimal coupling, maximum cohesion
- Use dependency injection where possible

## 🔧 CURSOR IDE SPECIFIC RULES

### Code Generation
- Generate code in appropriate subdirectories
- Use existing module patterns
- Follow established naming conventions
- Maintain consistent code style

### File Creation
- Always check if file belongs in root before creating
- Use descriptive, purpose-driven names
- Create necessary parent directories
- Update .gitignore for new file types

### Refactoring
- Move misplaced files to correct directories
- Update imports when moving files
- Maintain backward compatibility
- Update documentation for structural changes

## 📝 NAMING CONVENTIONS

### Files
- Use kebab-case for HTML/CSS: `game-ui.css`
- Use camelCase for JavaScript: `gameEngine.js`
- Use snake_case for Python: `genetic_algorithm.py`
- Use PascalCase for classes: `GameEngine`

### Directories
- Use kebab-case: `ai-training/`
- Use descriptive names: `visualization/`
- Avoid abbreviations: `utils/` not `util/`

## 🧪 TESTING RULES

### Test File Organization
```
temp/tests/
├── unit/                        # Unit tests
├── integration/                 # Integration tests
├── e2e/                         # End-to-end tests
└── fixtures/                    # Test data
```

### Test Cleanup
- Remove test files after completion
- Clean up test data
- Reset test environment
- Remove temporary test artifacts

## 🐛 DEBUGGING RULES

### Debug File Management
```
DEBUG/
├── logs/                        # Debug logs
│   └── action-monitoring/        # GitHub Actions monitoring logs
├── dumps/                       # Memory dumps
├── traces/                      # Execution traces
├── reports/                     # Debug reports
├── screenshots/                 # Debug screenshots
├── recordings/                  # Debug recordings
└── analysis/                    # Debug analysis files
```

### Debug Features for Better Debugging
- **Action Monitoring**: Real-time GitHub Actions workflow monitoring with detailed failure logs
- **Timezone-Aware Filtering**: Monitor only recent workflows (last 10 minutes) to focus on current issues
- **Smart Exit Logic**: Exits immediately when no workflows are running/queued
- **Detailed Logging**: Comprehensive logs saved to `DEBUG/logs/action-monitoring/`
- **Failure Analysis**: Automatic collection of failed workflow logs with run details
- **Status Summaries**: Clear visual status reports with success/failure counts

### Debug Cleanup
- Remove debug files after fixing issues
- Clean up debug logs
- Remove temporary debug code
- Reset debug environment

## 📊 LOGGING RULES

### Log File Organization
```
temp/logs/
├── application/                 # Application logs
├── errors/                      # Error logs
├── performance/                 # Performance logs
└── audit/                       # Audit logs
```

### Log Cleanup
- Rotate log files regularly
- Remove old log files
- Compress archived logs
- Monitor log file sizes

## 🔄 WORKFLOW RULES

### Main Branch Protection (CRITICAL)
- **MANDATORY**: Before ANY commit to main branch, run `./.github/_local_action_monitor main`
- **MANDATORY**: Before ANY merge to main branch, run `./.github/_local_action_monitor main`
- **FAIL-SAFE**: If any GitHub Action fails, DO NOT proceed with main branch operations
- **VERIFICATION**: All CI/CD pipelines must be green before main branch changes
- **MONITORING**: Wait for ALL workflows to complete before proceeding
- **⚠️ WARNING**: Violating this rule may break the build and cause deployment issues

### GitHub Actions Monitoring
- **Local Action Monitor**: Use `./.github/_local_action_monitor [commit] [max-wait-minutes]` to monitor workflow runs
- **Quick Status Check**: Use `./.github/scripts/quick-check.sh [commit]` for immediate status
- **Monitor Behavior**: 
  - Filters for workflows from last 10 minutes only
  - Exits immediately if no recent workflows found
  - Collects detailed logs from failed runs
  - Waits until ALL workflows complete (success or failure)
- **Usage Examples**:
  - `./.github/_local_action_monitor main 30` - Monitor main branch for up to 30 minutes
  - `./.github/_local_action_monitor` - Monitor main branch for up to 60 minutes (default)
  - `./.github/scripts/quick-check.sh` - Quick status check without waiting

### Before Committing
1. Run local action monitor to check workflow status
2. Run cleanup script
3. Remove temporary files
4. Clean up debug code
5. Update documentation
6. Run verification tests

### Main Branch Protection Rules
- **ALWAYS run local action monitor** before committing to main branch
- **ALWAYS run local action monitor** before merging PRs to main branch
- **MANDATORY**: Use `./.github/_local_action_monitor main [max-wait-minutes]` to ensure all actions are passing
- **FAIL-SAFE**: If any action fails, DO NOT commit/merge until all issues are resolved
- **MONITORING**: Wait for ALL workflows to complete (success or failure) before proceeding
- **VERIFICATION**: Confirm all CI/CD pipelines are green before main branch operations

### After Testing
1. Remove test artifacts
2. Clean up test data
3. Reset test environment
4. Update test documentation

### After Debugging
1. Remove debug files
2. Clean up debug logs
3. Remove temporary code
4. Document fixes

## 🚀 DEPLOYMENT RULES

### Production Build
- Exclude debug files
- Remove test files
- Clean up temporary files
- Optimize for production

### Development Build
- Include necessary debug tools
- Keep test files accessible
- Maintain development environment
- Document development setup

## 📋 MAINTENANCE RULES

### Regular Cleanup
- Weekly: Remove old temporary files
- Monthly: Clean up debug artifacts
- Quarterly: Review file organization
- Annually: Refactor if needed

### File Monitoring
- Monitor root directory for pollution
- Check for misplaced files
- Verify proper organization
- Update rules as needed

## 🎯 QUALITY GATES

### Before Merge
- All temporary files removed
- Debug code cleaned up
- Files in correct directories
- Documentation updated

### Before Release
- Production build clean
- No debug artifacts
- Proper file organization
- All tests passing

## 📚 DOCUMENTATION RULES

### Keep Updated
- Update README for structural changes
- Document new file organization
- Maintain architecture documentation
- Keep rules current

### File Documentation
- Document file purposes
- Explain directory structures
- Maintain change logs
- Keep documentation clean

---

## 🚨 VIOLATION HANDLING

### Immediate Actions
1. Move misplaced files to correct directories
2. Remove temporary files
3. Clean up debug artifacts
4. Update .gitignore if needed

### Prevention
1. Use file templates
2. Follow naming conventions
3. Regular cleanup checks
4. Automated cleanup scripts

Remember: Clean code is maintainable code. Keep the project organized and professional! 🎮
